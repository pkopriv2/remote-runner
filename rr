#! /bin/bash

export rr_home=${rr_home:-$HOME/.rr}
export rr_host_home=${rr_host_home:-$rr_home/hosts}
export rr_archive_home=${rr_archive_home:-$rr_home/archives}
export rr_role_home=${rr_role_home:-$rr_home/roles}

source $rr_home/local/require.sh

declare -A globals
declare -A attributes

require "lib/login.sh"
require "lib/inet.sh"
require "lib/array.sh"
require "local/log.sh"
require "local/msg.sh"
require "host.sh"
require "key.sh"
require "role.sh"
require "archive.sh"
require "fileserver.sh"

IFS=$'\n'
unalias "rm" &> /dev/null

# Determines the host environment.  This will set the following
# global variables:
# 	- key
#   - roles
# 
# @param 1 - The host environment to source
#
_host_env() {
	log_info "Sourcing host environment: $1"

	key="default"
	key() {
		key=${1:-"default"}
	}

	roles=()
	roles() {
		roles+=( $* )
	}

	if [[ ! -f $rr_host_home/$1.sh ]] 
	then
		fail "Host file [$1] does not exist."
	fi 

	if ! source $rr_host_home/$1.sh
	then
		fail "Error sourcing host file [$host]"
	fi

	roles=( $(array_uniq "${roles[@]}") )

	unset -f key
	unset -f roles
}

# Given a list of roles, this method will source
# all the role files and upadate the following global
# attributes:
#
#   - attributes
# 	- archives
# 
# @param 1..n - The roles to source.
#
_role_env() {
	attributes=()
	attr() {
		attributes+=(["$1"]=$2)
	}

	archives=()
	archives() {
		archives+=( $* )
	}

	for role in "${@}"
	do
		if [[ ! -f $rr_role_home/$role.sh ]] 
		then
			fail "Unable to determine run list for host [$1].  Role [$role] does not exist."
		fi 

		if ! source $rr_role_home/$role.sh
		then 
			fail "Error sourcing role file [$role]: $err"
		fi
	done

	archives=( $(array_uniq "${archives[@]}") )

	unset -f attr
	unset -f archives 
}

# Given a key name determine the keyfile and
# add it to the ssh connection agent. This
# will set the following global attributes:
#
# 	- key_file
#
# @param 1 - The name of the key
#
_key_env() {
	key_file=$rr_key_home/id_rsa.$key

	if [[ ! -f $key_file ]] 
	then 
		fail "That key file [$key_file] doesn't exist!"
	fi

	if ! ssh-add $key_file  &> /dev/null
	then
		fail "Unable to source the key file [$key_file]"
	fi 
}


# Given the target machine, this method will print the
# runtime library to stdout.
#
# @param 1 - The target host.
_runtime_lib() {
	cat - <<-EOH
	server_ip=$(inet_src_ip "$(login_get_host $1)")
	EOH

	for key in "${!attributes[@]}"
	do
		echo "$key=${attributes[$key]}"
	done

	for key in "${!globals[@]}"
	do
		echo "$key=${globals[$key]}"
	done

	for script in $rr_home/remote/*.sh
	do
		cat $script
	done

	for script in $rr_home/lib/*.sh
	do
		cat $script
	done

	for script in $rr_home/dsl/*.sh
	do
		cat $script
	done
}

# Copy over the runtime library to a particular
# host.  This will copy an archive to the
# remote host to: /tmp/archive.sh
# 
# The archive will consist of the following scripts:
# 	- rr.sh - The runtime library.
#   - archive_name::archive_script.sh - The archive script.  There 
# 		will be one for each archive that will be executed on the
# 		host
# 	- execute.sh - A script to actually execute the archives,
# 		and perform cleanup.	
#
# @param 1 - The host to which to transfer.
# @param 2 - The identity key to use
# @param 3..n - The archives to include in the copy.
_remote_lib_copy() {
	local host=$1
	local key_file=$2
	local archives=( ${@:3} )

	log_info "Building archive library from archives: $(array_print ${archives[@]})"

	{
		_runtime_lib $host
	} | tee /tmp/lib.sh | cat - > /tmp/rr.sh || fail "Failed to build runtime lib"

	(
		builtin cd /tmp	
		tar -cf $host.tar rr.sh 
		local ret=$?
		rm -f rr.sh
		exit $ret
	) || fail "Unable to build library tar."

	for archive in "${archives[@]}"
	do
		log_debug "Building archive script [$archive]"

		local archive_name=$(_archive_get_name $archive)
		local archive_script=$(_archive_get_script $archive)
		local script=$rr_archive_home/$archive_name/scripts/$archive_script.sh

		if [ ! -f $script ]
		then
			fail "Unable to locate archive [$archive]"
		fi

		{
			echo -ne ". /tmp/rr.sh; $archive_name::$archive_script() { archive_name=$archive_name;"
			cat $script
			echo "}; $archive_name::$archive_script;"
		} | cat - > /tmp/$archive_name::$archive_script.sh || fail "Failed to build archive script [$archive]"

		(
			builtin cd /tmp	
			tar -f $host.tar --append $archive_name::$archive_script.sh 
			local ret=$?
			rm -f $archive_name::$archive_script.sh
			exit $ret
		) || fail "Unable to build library tar."

		cmd+="if [[ -z \$ret ]] || [[ \$ret -eq 0 ]]; then bash /tmp/$archive_name::$archive_script.sh; ret=\$?; fi; rm /tmp/$archive_name::$archive_script.sh; " 
	done

	cmd+="rm /tmp/rr.sh; exit \$ret"

	log_debug "Building execute script."

	(
		echo "$cmd" > /tmp/execute.sh
		builtin cd /tmp
		tar -f $host.tar --append execute.sh 
		ret=$?
		rm -f /tmp/execute.sh
		exit $ret
	) || fail "Unable to build execute script."


	log_debug "Copying library to remote host [$host]"

	(
		scp -i $key_file /tmp/$host.tar $host:/tmp/archive.tar
		ret=$?
		rm -f /tmp/$host.tar 
		exit $ret
	) || fail "Error transferring archives to host [$host]"
}

# Execute the archive on the remote host. This function assumes
# that the archive has been copied to the location at
# /tmp/archive.sh and when expanded has a script called
# execute.sh.
#
# @param 1 - The host to which to transfer.
# @param 2 - The identity key to use
# @param 3..n - The archives to include in the copy.
_remote_lib_execute() {
	local host=$1
	local key_file=$2
	local archives=( ${@:3} )

	log_info "Executing archives on host [$host] : $( array_print ${archives[@]} )"

	local cmd="tar -xf /tmp/archive.tar -C /tmp && "
	if [[ -n $rr_sudo ]] && $rr_sudo 
	then
		cmd+="sudo "
	fi

	cmd+="bash /tmp/execute.sh; "
	cmd+="ret=\$?; rm /tmp/archive.tar /tmp/execute.sh; exit \$ret"
	
	fileserver_start $rr_archive_home \
		|| fail "Error starting fileserver"

	ssh -t -i $key_file $host "$cmd"

	ret=$?

	fileserver_stop

	if [ $ret -ne 0 ]
	then
		fail "Failed to remote execute archives on host [$host]: $( array_print ${archives[@]} )"
	fi
}

execute() {
	if [[ $# < 1 ]]
	then
		error "Must provide a host regexp."
		exit 1
	fi

	while getopts ":l:a:p:s" opt 
	do
		case $opt in
			l)
				log_level=$OPTARG
				;;
			a) 
				archive+=( $OPTARG )
				;;
			p) 
				rr_archive_home=$OPTARG 
				;;
			s)
				rr_sudo=true 
		esac 
	done

	local host_list=()
	for host_regexp in "${@}"
	do
		host_list+=( $( _host_match $host_regexp) )
	done
	host_list=( $(array_uniq ${host_list[@]}) )

	log_info "Hosts have expanded to: $(array_print "${host_list[@]}") "
	for host in "${host_list[@]}"
	do
		(
		# Source the host file.  This will set the following
		# global variables:
		# 	- key
		#   - roles
		#
		_host_env $host

		# Source the roles.  This will set the following
		# global variables:
		#   - attributes
		#   - archives
		#
		_role_env ${roles[@]}

		if [[ -n $archive ]]
		then
			archives=( "${archive[@]}" )
		fi

		log_info "Runlist has expanded to: $(array_print ${archives[@]}) "


		# Check to see if any archives have been applied to
		# this host.  If not, then we don't need to continue
		if [[ ${#archives} == 0 ]] 
		then
			log_info "No archives to execute."
			exit 0
		fi

		# Determine the necessary ssh key to use to 
		# run on this host.  Add the identity file
		# to limit the number of times that the passphrase
		# is requested. This will set the following 
		# global variables:
		# 	- key_file
		#
		_key_env $key

		_remote_lib_copy $host $key_file "${archives[@]}"
		_remote_lib_execute $host $key_file "${archives[@]}"

		) || fail "Error executing host [$host] runlist."
	done
}


help() {
	info "** Global Commands **"

	echo 
	echo "rr [options] [HOST] [HOST]*"
	echo

	local subcommands=( key host role archive )
	for cmd in "${subcommands[@]}" 
	do
		"$cmd"_help
		echo 
	done
}


args=($*)
action="${args[0]}"
shift

case "$action" in
	key|host|role|archive)
		"$action"_action "$@"
		;;
	help)
		help
		;;	
	*)
		execute "${args[@]}" 
		;;
esac
