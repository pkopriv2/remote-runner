#! /bin/bash

export rr_home=${rr_home:-$HOME/.rr}
export rr_host_home=${rr_host_home:-$rr_home/hosts}

IFS=$'\n'

source $rr_home/local/require.sh

declare -A globals
declare -A attributes

require "lib/login.sh"
require "lib/inet.sh"
require "lib/array.sh"
require "local/log.sh"
require "host.sh"
require "key.sh"
require "role.sh"
require "archive.sh"
require "fileserver.sh"

# Determines the host environment.  This will set the following
# global variables:
# 	- key
#   - roles
# 
# @param 1 - The host environment to source
#
_host_env() {
	log_debug "Sourcing host environment: $1"

	key="default"
	key() {
		key=${1:-"default"}
	}

	roles=()
	roles() {
		roles+=( $* )
	}

	if [[ ! -f $rr_host_home/$1.sh ]] 
	then
		fail "Host file [$1] does not exist."
	fi 

	if ! source $rr_host_home/$1.sh
	then
		fail "Error sourcing host file [$host]"
	fi

	roles=( $(array_uniq "${roles[@]}") )

	unset -f key
	unset -f roles
}

# Given a list of roles, this method will source
# all the role files and upadate the following global
# attributes:
#
#   - attributes
# 	- archives
# 
# @param 1..n - The roles to source.
#
_role_env() {
	attributes=()
	attr() {
		attributes+=(["$1"]=$2)
	}

	archives=()
	archives() {
		archives+=( $* )
	}

	for role in "${@}"
	do
		if [[ ! -f $rr_role_home/$role.sh ]] 
		then
			fail "Unable to determine run list for host [$1].  Role [$role] does not exist."
		fi 

		if ! source $rr_role_home/$role.sh
		then 
			fail "Error sourcing role file [$role]: $err"
		fi
	done

	archives=( $(array_uniq "${archives[@]}") )
	log_info "Runlist has expanded to: $(array_print ${archives[@]}) "

	unset -f attr
	unset -f archives 
}

# Given a key name determine the keyfile and
# add it to the ssh connection agent. This
# will set the following global attributes:
#
# 	- key_file
#
# @param 1 - The name of the key
#
_key_env() {
	key_file=$rr_key_home/id_rsa.$key

	if [[ ! -f $key_file ]] 
	then 
		fail "That key file [$key_file] doesn't exist!"
	fi

	if ! ssh-add $key_file  &> /dev/null
	then
		fail "Unable to source the key file [$key_file]"
	fi 
}


# Given the target machine, this method will print the
# runtime library to stdout.
#
# @param 1 - The target host.
_runtime_lib() {
	cat - <<-EOH
	server_ip=$(inet_src_ip "$(login_get_host $1)")
	EOH

	for key in "${!attributes[@]}"
	do
		echo "$key=${attributes[$key]}"
	done

	for key in "${!globals[@]}"
	do
		echo "$key=${globals[$key]}"
	done

	for script in $rr_home/remote/*.sh
	do
		cat $script
	done

	for script in $rr_home/lib/*.sh
	do
		cat $script
	done

	for script in $rr_home/dsl/*.sh
	do
		cat $script
	done
}

# Execute an archive
#
# @param 1 - The host on which to run the archive
# @param 2 - The key file to send with the ssh request
# @param 3 - The archive to execute
_archive_execute() {
	local host=$1
	local key_file=$2
	local archive=$3

	log_info "Executing archive [$archive] on host [$host]"

	local archive_name=$(_archive_get_name $archive)
	local archive_script=$(_archive_get_script $archive)

	local script=$rr_archive_home/$archive_name/scripts/$archive_script.sh
	if [ ! -f $script ]
	then
		fail "Unable to locate archive [$archive]"
	fi

	fileserver_start $rr_archive_home/$archive_name/files 

	{
		_runtime_lib $host $archive

		cat - <<-EOH
			archive_name=$archive_name
			archive_script=$archive_script
			roles=(${roles[*]})
		EOH
	} | ssh -t -i $key_file $host "cat - > /tmp/rr.sh"

	if [ $? -ne 0 ]
	then
		fail "Failed to send runtime library to host [$host]"
	fi

	{
		echo -ne ". /tmp/rr.sh; $archive_name::$archive_script() { echo &> /dev/null;"
		cat $script
		echo "}; $archive_name::$archive_script;"
	} | ssh -t -i $key_file $host "bash /dev/stdin; rm /tmp/rr.sh"

	ret=$?

	fileserver_stop

	if [ $ret -ne 0 ]
	then
		fail "Failed to remote execute archive [$archive] on host [$host]"
	fi
}

execute() {
	if [[ $# < 1 ]]
	then
		log_error "Must provide a host regexp."
		exit 1
	fi

	# Determine the hosts on which this will run.
	local host_list=()
	for host_regexp in "${@}"
	do
		host_list+=( $( _host_match $host_regexp) )
	done
	host_list=( $(array_uniq ${host_list[@]}) )

	log_info "Hosts have expanded to: $(array_print "${host_list[@]}") "

	for host in "${host_list[@]}"
	do

		(
		# Source the host file.  This will set the following
		# global variables:
		# 	- key
		#   - roles
		#
		_host_env $host

		# Source the roles.  This will set the following
		# global variables:
		#   - attributes
		#   - archives
		#
		_role_env ${roles[@]}

		# Check to see if any archives have been applied to
		# this host.  If not, then we don't need to continue
		if [[ ${#archives} == 0 ]] 
		then
			log_info "No archives to execute."
			exit 0
		fi

		# Determine the necessary ssh key to use to 
		# run on this host.  Add the identity file
		# to limit the number of times that the passphrase
		# is requested. This will set the following 
		# global variables:
		# 	- key_file
		#
		_key_env $key

		for archive in "${archives[@]}"
		do
			_archive_execute $host $key_file $archive
		done

		) || fail "Error executing host [$host] runlist."
	done
}

help() {
	log_error "Undefined"
}


args=($*)
action="${args[0]}"
shift

case "$action" in
	key|host|role|archive)
		"$action"_action "$@"
		;;
	help)
		help
		;;	
	*)
		execute "${args[@]}" 
		;;
esac
